# useEffect

useEffect is used to run functions (which we will call side effects) every time the function renders (or re-renders).

It accepts a
callback function which React will call after the DOM has been updated and an array, called the dependency array:
```javascript
React.useEffect(() => {
  // your side-effect code here.
  // this is where you can make HTTP requests or interact with browser APIs.
}, [])
```

The dependency array is fundamental in understanding how side effects work: its role is to make sure our side effects are run **only** when the value in the dependency array changes.

Here's an example of useEffect in action:

```jsx
function Greeting({initialName = ''}) {
    /* passing a callback instead of the value itself as the initial state
     will prevent useState from calling it on every re-render*/
  const [name, setName] = React.useState(
    ()=>window.localStorage.getItem('name') || initialName,
  )
    /*whenever the component is re-rendered, 
    useEffect will set our current state to local storage*/
  React.useEffect(() => {
    window.localStorage.setItem('name', name)
  })

  function handleChange(event) {
    setName(event.target.value)
  }

  return (
    <div>
      <form>
        <label htmlFor="name">Name: </label>
        <input value={name} onChange={handleChange} id="name" />
      </form>
      {name ? <strong>Hello {name}</strong> : 'Please type your name'}
    </div>
  )
}
```

it's important to keep in mind the lifecycle of a React[[hook-flow]] app whenever we decide to use side effects to prevent race conditions and unnecessary re-renders.

useEffect also can be used with a **cleanup** function that is used when the component is unmounted (in classes components, this would be the `componentWillUnmount` function). 
here's a quick example:
```javascript
  useEffect(() => {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    // Specify how to clean up after this effect:
    return function cleanup() {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });
  
```

useEffect can also be used to perform HTTP requests once our components have rendered. Using asynchronous operations in useEffect has other implications:


```javascript
// this does not work, don't do this:
React.useEffect(async () => {
  const result = await doSomeAsyncThing()
  // do something with the result
})
```

The reason this doesn't work is because when you make a function async, it
automatically returns a promise (whether you're not returning anything at all,
or explicitly returning a function). This is due to the semantics of async/await
syntax. So if you want to use async/await, the best way to do that is like so:

```javascript
React.useEffect(() => {
  async function effect() {
    const result = await doSomeAsyncThing()
    // do something with the result
  }
  effect()
})
```

To make it look cleaner you can also use the `.then()` syntax:

```javascript
React.useEffect(() => {
  doSomeAsyncThing().then(result => {
    // do something with the result
  })
})
```

[//begin]: # "Autogenerated link references for markdown compatibility"
[hook-flow]: hook-flow.md "Hook Flow"
[//end]: # "Autogenerated link references"