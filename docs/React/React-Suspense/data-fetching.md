# Simple Data Fetching

Suspense API. Here's the basic idea:

```javascript
function Component() {
  if (data) {
    return <div>{data.message}</div>
  }
  throw promise
  // React will catch this, find the closest "Suspense" component
  // and "suspend" everything from there down from rendering until the
  // promise resolves.
}

ReactDOM.createRoot(rootEl).render(
  <React.Suspense fallback={<div>loading...</div>}>
    <Component />
  </React.Suspense>,
)
```
For the documentation of React.Suspense, refer to [`<React.Suspense />`](https://reactjs.org/docs/concurrent-mode-reference.html#suspense)

The basic idea behind asynchronous rendering is that there is no reason to render a component that is based on data until we have data.
The most common way to use this pattern is to leverage the `Promise` API.

Here's an example of preloading an image:

```javascript
function preloadImage(src) {
  return new Promise(resolve => {
    const img = document.createElement('img')
    img.src = src
    img.onload = () => resolve(src)
  })
}
```

And here's an example used to preload a resource using a resource factory[[factory]]:
```javascript
function createResource(promise) {
  let status = 'pending'
  let result = promise.then(
    resolved => {
      status = 'success'
      result = resolved
    },
    rejected => {
      status = 'error'
      result = rejected
    },
  )
  //notice that the return value is a function 
  //that reads inside the state inside this closure
  return {  
    read() {
      if (status === 'pending') throw result
      if (status === 'error') throw result
      if (status === 'success') return result
      throw new Error('This should be impossible')
    },
  }
}
```

[//begin]: # "Autogenerated link references for markdown compatibility"
[factory]: ../../Design-patterns/factory.md "factory"
[//end]: # "Autogenerated link references"